{{/*
RBAC Configuration for mcp-kubernetes

IMPORTANT: Authentication Mode Context
======================================
The RBAC resources in this file are used ONLY when OAuth Downstream is DISABLED.

When enableDownstreamOAuth: false (Service Account Mode):
  - These ClusterRoles/Roles grant permissions to the ServiceAccount
  - All Kubernetes API operations use the ServiceAccount's identity
  - All users share the ServiceAccount's RBAC permissions

When enableDownstreamOAuth: true (OAuth Downstream Mode):
  - These RBAC resources are NOT used for Kubernetes API operations
  - User's OAuth token authenticates directly to the Management Cluster
  - Users must have their own RBAC permissions on both MC and WCs
  - The ServiceAccount only needs permissions for pod lifecycle (network, etc.)
  - Use rbac.profile: "minimal" for production deployments

RBAC Profiles:
  - minimal:  Pod lifecycle only (recommended for downstream OAuth)
  - readonly: Read-only access to common resources
  - standard: Read + limited write operations
  - admin:    Full access (explicit opt-in)

See docs/rbac-security.md for detailed requirements per deployment mode.
*/}}

{{- define "mcp-kubernetes.rbac.minimalRules" -}}
# Minimal profile: Only what's needed for pod lifecycle
# Suitable for downstream OAuth mode where user tokens are used
# No access to Kubernetes API resources - empty rules
{{- end }}

{{- define "mcp-kubernetes.rbac.readonlyRules" -}}
# Readonly profile: Read-only access to common resources
rules:
  # Core resources (read-only)
  - apiGroups: [""]
    resources: ["pods", "services", "endpoints", "nodes", "namespaces", "configmaps", "persistentvolumes", "persistentvolumeclaims", "events"]
    verbs: ["get", "list", "watch"]

  # Secrets are excluded from readonly for security

  # Apps resources (read-only)
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
    verbs: ["get", "list", "watch"]

  # Networking resources (read-only)
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses", "networkpolicies"]
    verbs: ["get", "list", "watch"]

  # Storage resources (read-only)
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses", "volumeattachments"]
    verbs: ["get", "list", "watch"]

  # Metrics resources (read-only)
  - apiGroups: ["metrics.k8s.io"]
    resources: ["pods", "nodes"]
    verbs: ["get", "list"]

  # Custom resources (read-only)
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list", "watch"]

  # RBAC resources (read-only, no create/update/delete)
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
    verbs: ["get", "list", "watch"]

  # Batch resources (read-only)
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch"]

  # Autoscaling resources (read-only)
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["get", "list", "watch"]

  # Policy resources (read-only)
  - apiGroups: ["policy"]
    resources: ["poddisruptionbudgets"]
    verbs: ["get", "list", "watch"]
{{- end }}

{{- define "mcp-kubernetes.rbac.standardRules" -}}
# Standard profile: Read + limited write operations
rules:
  # Core resources
  - apiGroups: [""]
    resources: ["pods", "services", "endpoints", "nodes", "namespaces", "configmaps", "secrets", "persistentvolumes", "persistentvolumeclaims", "events"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Apps resources
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Networking resources
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses", "networkpolicies"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Storage resources (read-only, no create/delete)
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses", "volumeattachments"]
    verbs: ["get", "list", "watch"]

  # Metrics resources
  - apiGroups: ["metrics.k8s.io"]
    resources: ["pods", "nodes"]
    verbs: ["get", "list"]

  # Custom resources (read-only)
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list", "watch"]

  # RBAC resources (read-only, no create/update/delete for safety)
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
    verbs: ["get", "list", "watch"]

  # Batch resources
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Autoscaling resources
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Policy resources
  - apiGroups: ["policy"]
    resources: ["poddisruptionbudgets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
{{- end }}

{{- define "mcp-kubernetes.rbac.adminRules" -}}
# Admin profile: Full access (use with caution)
rules:
  # Core resources (full access)
  - apiGroups: [""]
    resources: ["pods", "services", "endpoints", "nodes", "namespaces", "configmaps", "secrets", "persistentvolumes", "persistentvolumeclaims", "events", "serviceaccounts"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Pod exec and logs
  - apiGroups: [""]
    resources: ["pods/exec", "pods/log", "pods/portforward"]
    verbs: ["get", "create"]

  # Apps resources (full access)
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Networking resources (full access)
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses", "networkpolicies"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Storage resources (full access)
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses", "volumeattachments"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Metrics resources
  - apiGroups: ["metrics.k8s.io"]
    resources: ["pods", "nodes"]
    verbs: ["get", "list"]

  # Custom resources (full access)
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # RBAC resources (full access - HIGH PRIVILEGE)
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "rolebindings", "clusterroles", "clusterrolebindings"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Batch resources (full access)
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Autoscaling resources (full access)
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Policy resources (full access)
  # Note: PodSecurityPolicies removed - deprecated in K8s 1.21, removed in 1.25
  - apiGroups: ["policy"]
    resources: ["poddisruptionbudgets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

  # Admission resources
  - apiGroups: ["admissionregistration.k8s.io"]
    resources: ["mutatingwebhookconfigurations", "validatingwebhookconfigurations"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
{{- end }}

{{- if and .Values.serviceAccount.create .Values.rbac.create -}}
{{/*
SECURITY: When OAuth Downstream is enabled, users authenticate with their own tokens.
The ServiceAccount should have NO Kubernetes API permissions (minimal profile enforced).
This prevents the ServiceAccount from being used to bypass user RBAC.
*/}}
{{- $downstreamOAuth := .Values.mcpKubernetes.oauth.enableDownstreamOAuth -}}
{{- $requestedProfile := .Values.rbac.profile | default "standard" -}}
{{- $profile := ternary "minimal" $requestedProfile $downstreamOAuth -}}
{{- if and .Values.rbac.custom.enabled $downstreamOAuth -}}
{{- fail "CONFIGURATION ERROR: rbac.custom.enabled cannot be used with enableDownstreamOAuth. Custom RBAC rules are ignored when OAuth Downstream is enabled because user tokens are used for all API operations. The ServiceAccount requires no Kubernetes API permissions in this mode." -}}
{{- end -}}
{{- if and (eq $profile "admin") (not .Values.rbac.adminConfirmation) -}}
{{- fail "SECURITY: The 'admin' RBAC profile grants dangerous permissions including RBAC management (privilege escalation), pod exec (container escape), and webhook configuration (API interception). To use this profile, you must explicitly set 'rbac.adminConfirmation: true' to confirm you understand these risks." -}}
{{- end -}}
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
  annotations:
    mcp-kubernetes.giantswarm.io/rbac-profile: {{ $profile | quote }}
    {{- if not $downstreamOAuth }}
    # This ClusterRole is actively used for Kubernetes API operations
    mcp-kubernetes.giantswarm.io/rbac-mode: "service-account"
    {{- else }}
    # OAuth Downstream is enabled - minimal profile enforced
    # User tokens are used for all Kubernetes API operations
    mcp-kubernetes.giantswarm.io/rbac-mode: "oauth-downstream"
    mcp-kubernetes.giantswarm.io/enforced-profile: "minimal"
    {{- if ne $requestedProfile "minimal" }}
    mcp-kubernetes.giantswarm.io/requested-profile: {{ $requestedProfile | quote }}
    mcp-kubernetes.giantswarm.io/note: "Requested profile overridden to 'minimal' because enableDownstreamOAuth is true"
    {{- end }}
    {{- end }}
    {{- if eq $profile "admin" }}
    security.kubernetes.io/warning: "Admin profile grants extensive permissions. Use with caution."
    {{- end }}
{{- if and .Values.rbac.custom.enabled (not $downstreamOAuth) }}
# Custom RBAC rules (only when downstream OAuth is disabled)
rules:
{{ toYaml .Values.rbac.custom.rules | indent 2 }}
{{- else if eq $profile "minimal" }}
{{- include "mcp-kubernetes.rbac.minimalRules" . }}
{{- else if eq $profile "readonly" }}
{{- include "mcp-kubernetes.rbac.readonlyRules" . }}
{{- else if eq $profile "standard" }}
{{- include "mcp-kubernetes.rbac.standardRules" . }}
{{- else if eq $profile "admin" }}
{{- include "mcp-kubernetes.rbac.adminRules" . }}
{{- else }}
{{- fail (printf "Unknown RBAC profile: %s. Valid profiles are: minimal, readonly, standard, admin" $profile) }}
{{- end }}

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ include "mcp-kubernetes.fullname" . }}
subjects:
  - kind: ServiceAccount
    name: {{ include "mcp-kubernetes.serviceAccountName" . }}
    namespace: {{ .Release.Namespace }}
{{- end }}

{{/*
CAPI Mode RBAC - Always created when CAPI mode is enabled

This RBAC is REQUIRED for CAPI mode to function, regardless of OAuth mode:

When enableDownstreamOAuth: false (Service Account Mode):
  - ServiceAccount uses these permissions for all CAPI operations
  - Users share the ServiceAccount's permissions

When enableDownstreamOAuth: true (OAuth Downstream Mode):
  - Users authenticate via OAuth for CAPI cluster discovery
  - ServiceAccount STILL needs secret/configmap access for kubeconfig/CA retrieval
  - This is the "split credential" security model (see docs/rbac-security.md)

The workloadClusterAuth.mode determines what resources are accessed:
  - "impersonation": Secrets (kubeconfig with admin credentials)
  - "sso-passthrough": ConfigMaps (CA certificates only - public keys)
*/}}
{{- if and .Values.serviceAccount.create .Values.capiMode.enabled }}
---
# ClusterRole for CAPI resource discovery and authentication
# NOTE: Used by ServiceAccount when enableDownstreamOAuth: false
#       Users need equivalent RBAC when enableDownstreamOAuth: true
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}-capi
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
  {{- if .Values.mcpKubernetes.oauth.enableDownstreamOAuth }}
  annotations:
    mcp-kubernetes.giantswarm.io/note: "Users need these permissions in their own RBAC when OAuth Downstream is enabled"
  {{- end }}
rules:
  # CAPI cluster discovery (read-only)
  # In OAuth Downstream mode, users need this permission in their own ClusterRoleBinding
  - apiGroups: ["cluster.x-k8s.io"]
    resources:
      - clusters
      - clusters/status
      - machinepools
      - machinepools/status
      - machinedeployments
      - machinedeployments/status
      - machines
      - machines/status
    verbs: ["get", "list", "watch"]

  # Infrastructure provider resources (read-only, for cluster details)
  # Note: Uses wildcard to support any CAPI infrastructure provider (AWS, Azure, GCP, vSphere, etc.)
  # For single-provider deployments, consider restricting to specific resources.
  # See docs/rbac-security.md for provider-specific resource lists.
  - apiGroups: ["infrastructure.cluster.x-k8s.io"]
    resources: ["*"]
    verbs: ["get", "list"]

  # TokenReviews for validating tokens
  - apiGroups: ["authentication.k8s.io"]
    resources: ["tokenreviews"]
    verbs: ["create"]

  # SubjectAccessReviews for pre-flight permission checks
  - apiGroups: ["authorization.k8s.io"]
    resources: ["subjectaccessreviews", "selfsubjectaccessreviews"]
    verbs: ["create"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}-capi
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ include "mcp-kubernetes.fullname" . }}-capi
subjects:
  - kind: ServiceAccount
    name: {{ include "mcp-kubernetes.serviceAccountName" . }}
    namespace: {{ .Release.Namespace }}

{{/*
Cluster-wide secret access (only if explicitly enabled - NOT RECOMMENDED)
WARNING: This grants access to ALL secrets in the cluster
*/}}
{{- if .Values.capiMode.rbac.clusterWideSecrets }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}-secrets
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
  annotations:
    # Security warning annotation
    security.kubernetes.io/warning: "This role grants cluster-wide secret access. Use namespace-scoped roles instead."
rules:
  # HIGH PRIVILEGE - grants access to ALL secrets cluster-wide
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ include "mcp-kubernetes.fullname" . }}-secrets
  labels:
    {{- include "mcp-kubernetes.labels" . | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ include "mcp-kubernetes.fullname" . }}-secrets
subjects:
  - kind: ServiceAccount
    name: {{ include "mcp-kubernetes.serviceAccountName" . }}
    namespace: {{ .Release.Namespace }}
{{- end }}

{{/*
Namespace-scoped access for workload cluster authentication.
Creates Role and RoleBinding for each allowed namespace.

The resources accessed depend on the authentication mode:
- Impersonation mode: Secrets (kubeconfig with admin credentials)
- SSO Passthrough mode: ConfigMaps (CA certificates only - public keys)

SECURITY MODEL:
- Impersonation Mode:
    ServiceAccount reads kubeconfig secrets to access workload clusters.
    Uses admin credentials + impersonation headers for user identity.
    Requires secret read access.

- SSO Passthrough Mode:
    ServiceAccount only needs CA certificates (public information).
    CA certificates are stored in ConfigMaps, not Secrets.
    User's SSO token is forwarded directly to WC API servers.
    NO secret access required - significantly reduced privileges.
*/}}

{{- if eq ($.Values.capiMode.workloadClusterAuth.mode | default "impersonation") "sso-passthrough" }}
{{/*
SSO Passthrough Mode: ConfigMap access for CA certificates
CA certificates are public information and stored in ConfigMaps.
*/}}
{{- range .Values.capiMode.rbac.allowedNamespaces }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "mcp-kubernetes.fullname" $ }}-ca-configmaps
  namespace: {{ . }}
  labels:
    {{- include "mcp-kubernetes.labels" $ | nindent 4 }}
  annotations:
    mcp-kubernetes.giantswarm.io/wc-auth-mode: "sso-passthrough"
    mcp-kubernetes.giantswarm.io/resource-access: "configmaps-only"
    mcp-kubernetes.giantswarm.io/note: "Only CA ConfigMaps (${CLUSTER_NAME}{{ $.Values.capiMode.workloadClusterAuth.caConfigMapSuffix | default "-ca-public" }}) are accessed"
rules:
  # SSO Passthrough: Access to CA ConfigMaps
  # Only ${CLUSTER_NAME}-ca-public ConfigMaps are accessed
  # These contain the cluster's CA certificate (public key) for TLS verification
  # NO secret access is required in this mode
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "mcp-kubernetes.fullname" $ }}-ca-configmaps
  namespace: {{ . }}
  labels:
    {{- include "mcp-kubernetes.labels" $ | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ include "mcp-kubernetes.fullname" $ }}-ca-configmaps
subjects:
  - kind: ServiceAccount
    name: {{ include "mcp-kubernetes.serviceAccountName" $ }}
    namespace: {{ $.Release.Namespace }}
{{- end }}

{{- else }}
{{/*
Impersonation Mode: Secret access for kubeconfig credentials
*/}}
{{- range .Values.capiMode.rbac.allowedNamespaces }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "mcp-kubernetes.fullname" $ }}-secrets
  namespace: {{ . }}
  labels:
    {{- include "mcp-kubernetes.labels" $ | nindent 4 }}
  annotations:
    mcp-kubernetes.giantswarm.io/wc-auth-mode: "impersonation"
    {{- if $.Values.mcpKubernetes.oauth.enableDownstreamOAuth }}
    mcp-kubernetes.giantswarm.io/security-model: "privileged-secret-access"
    mcp-kubernetes.giantswarm.io/note: "ServiceAccount reads kubeconfig secrets; users DO NOT need secret access"
    {{- else }}
    mcp-kubernetes.giantswarm.io/security-model: "service-account"
    {{- end }}
rules:
  # Impersonation: Access to kubeconfig secrets in this namespace
  # ServiceAccount reads secrets on behalf of authenticated users
  # This enables impersonation-enforced access to workload clusters
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "mcp-kubernetes.fullname" $ }}-secrets
  namespace: {{ . }}
  labels:
    {{- include "mcp-kubernetes.labels" $ | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ include "mcp-kubernetes.fullname" $ }}-secrets
subjects:
  - kind: ServiceAccount
    name: {{ include "mcp-kubernetes.serviceAccountName" $ }}
    namespace: {{ $.Release.Namespace }}
{{- end }}
{{- end }}
{{- end }}
